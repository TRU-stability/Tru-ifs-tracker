<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRU Troth Covenant Console</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Use Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">

    <!-- CSS/Tailwind Configuration for the app -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'lime': {
                            50: '#f7fee7', 100: '#ecfccb', 200: '#d9f99d', 300: '#bef264',
                            400: '#a3e635', 500: '#84cc16', 600: '#65a30d', 700: '#4d7c0f',
                            800: '#3f6212', 900: '#365314', 950: '#1a2e05',
                        },
                        'tru-black': '#121212',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 min-h-screen antialiased">
    <div id="root"></div>

    <script type="module">
        // --- FIREBASE IMPORTS (Must be type="module") ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
        import { 
            getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged, signOut 
        } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, onSnapshot, collection, query, limit, 
            orderBy, updateDoc, writeBatch, arrayUnion, arrayRemove 
        } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";
        
        // Expose Firebase objects globally for the Babel script block to access
        window.FirebaseServices = {
            initializeApp, getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged, signOut,
            getFirestore, doc, setDoc, onSnapshot, collection, query, limit,
            orderBy, updateDoc, writeBatch, arrayUnion, arrayRemove
        };

        // --- Global Variable Access (MANDATORY) ---
        window.appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        window.firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        window.initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    </script>
    
    <!-- Babel script for JSX/React code -->
    <script type="text/babel">
        // Import React from the CDN load above
        const { useState, useEffect, useCallback, useMemo } = React;
        const { createRoot } = ReactDOM;

        // Destructure Firebase services from the window object exposed by the module script
        const {
            initializeApp, getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged, signOut,
            getFirestore, doc, setDoc, onSnapshot, collection, query, limit,
            orderBy, updateDoc, writeBatch, arrayUnion, arrayRemove
        } = window.FirebaseServices;

        const { appId, firebaseConfig, initialAuthToken } = window;


        // Utility to convert user ID for display (first 8 chars + ...)
        const formatUserId = (id) => `${id.substring(0, 8)}...`;

        // Constants
        const CORE_VALUES = [
            { id: 'integrity', label: 'Integrity (Honesty & Truthfulness)' },
            { id: 'functionality', label: 'Functionality (Execution & Competence)' },
            { id: 'sustainability', label: 'Sustainability (Long-Term Viability)' },
        ];
        const MAX_CORE_SCORE = 100;
        const INITIAL_COVENANT = {
            name: "New Covenant",
            status: "active", // active, paused, archived
            members: [], // List of userIds
            scores: {}, // { userId: { integrity: 50, functionality: 50, sustainability: 50 } }
            history: [], // [{ timestamp, event, details }]
            lastUpdate: Date.now()
        };

        // --- Firebase Initialization and Auth Setup ---
        const useFirebase = () => {
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [userId, setUserId] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);

            useEffect(() => {
                try {
                    const app = initializeApp(firebaseConfig);
                    const firestore = getFirestore(app);
                    const authService = getAuth(app);
                    
                    setDb(firestore);
                    setAuth(authService);

                    const unsubscribe = onAuthStateChanged(authService, async (user) => {
                        if (user) {
                            setUserId(user.uid);
                        } else {
                            // Sign in anonymously if no token is available for fresh state
                            if (initialAuthToken) {
                                await signInWithCustomToken(authService, initialAuthToken);
                            } else {
                                // Fallback for environments without initial token
                                await signInAnonymously(authService); 
                            }
                        }
                        setIsAuthReady(true);
                    });

                    // Cleanup subscription on unmount
                    return () => unsubscribe();

                } catch (e) {
                    console.error("Firebase Initialization Error:", e);
                    setIsAuthReady(true); // Treat as ready to handle errors in UI
                }
            }, []);

            return { db, auth, userId, isAuthReady };
        };

        // --- Firestore Data Logic ---
        const useCovenants = (db, userId, isAuthReady) => {
            const [covenants, setCovenants] = useState([]);
            const [currentCovenantId, setCurrentCovenantId] = useState(null);
            const [isLoading, setIsLoading] = useState(true);

            // Determine the correct path: Public collection for shared covenants
            const getCovenantsCollectionRef = useCallback(() => {
                if (!db) return null;
                return collection(db, 'artifacts', appId, 'public', 'data', 'covenants');
            }, [db]);

            // Load/Subscribe to Covenants
            useEffect(() => {
                if (!isAuthReady || !db || !userId) {
                    if (isAuthReady) setIsLoading(false);
                    return;
                }

                const q = query(
                    getCovenantsCollectionRef(),
                    orderBy('lastUpdate', 'desc'),
                    limit(20) // Limit to a reasonable number of covenants
                );

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const loadedCovenants = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data(),
                    }));
                    
                    setCovenants(loadedCovenants);
                    setIsLoading(false);

                    // If user is a member of any covenant and no current one is selected, select the first one.
                    if (!currentCovenantId) {
                        const userCovenants = loadedCovenants.filter(c => c.members.includes(userId));
                        if (userCovenants.length > 0) {
                            setCurrentCovenantId(userCovenants[0].id);
                        } else if (loadedCovenants.length > 0) {
                            setCurrentCovenantId(loadedCovenants[0].id); // Select a public one if no membership
                        }
                    }
                }, (error) => {
                    console.error("Error fetching covenants:", error);
                    setIsLoading(false);
                });

                return () => unsubscribe();
            }, [db, userId, isAuthReady, currentCovenantId, getCovenantsCollectionRef]);

            const currentCovenant = useMemo(() => 
                covenants.find(c => c.id === currentCovenantId), 
                [covenants, currentCovenantId]
            );
            
            // Helper to validate score input
            const validateScore = (score) => {
                const num = parseInt(score, 10);
                return isNaN(num) ? 0 : Math.max(0, Math.min(MAX_CORE_SCORE, num));
            };

            // --- Actions ---

            const createCovenant = useCallback(async (name) => {
                if (!db || !userId) return;
                setIsLoading(true);
                try {
                    const newCovenantRef = doc(getCovenantsCollectionRef());
                    const initialScores = CORE_VALUES.reduce((acc, val) => ({ ...acc, [val.id]: 50 }), {});

                    const newCovenantData = {
                        ...INITIAL_COVENANT,
                        name: name,
                        members: [userId],
                        scores: { [userId]: initialScores },
                        history: [{ 
                            timestamp: Date.now(), 
                            event: "Covenant Created", 
                            details: `Created by ${formatUserId(userId)}` 
                        }],
                        lastUpdate: Date.now()
                    };
                    
                    await setDoc(newCovenantRef, newCovenantData);
                    setCurrentCovenantId(newCovenantRef.id);
                } catch (e) {
                    console.error("Error creating covenant:", e);
                } finally {
                    setIsLoading(false);
                }
            }, [db, userId, getCovenantsCollectionRef]);

            const updateMemberScore = useCallback(async (covenantId, targetUserId, valueId, newScore) => {
                if (!db || !covenantId) return;

                try {
                    const covenantRef = doc(getCovenantsCollectionRef(), covenantId);
                    const validatedScore = validateScore(newScore);

                    const updatePayload = {
                        [`scores.${targetUserId}.${valueId}`]: validatedScore,
                        lastUpdate: Date.now(),
                        history: arrayUnion({ 
                            timestamp: Date.now(), 
                            event: "Score Updated", 
                            details: `${formatUserId(targetUserId)}'s ${valueId} score set to ${validatedScore}` 
                        })
                    };
                    
                    await updateDoc(covenantRef, updatePayload);
                } catch (e) {
                    console.error("Error updating score:", e);
                }
            }, [db, getCovenantsCollectionRef]);

            const addMember = useCallback(async (covenantId, newMemberId) => {
                if (!db || !covenantId || !newMemberId) return;
                
                // Check if member already exists (Firestore security rule would also handle this)
                const currentCovenant = covenants.find(c => c.id === covenantId);
                if (currentCovenant && currentCovenant.members.includes(newMemberId)) {
                    console.warn("User already a member.");
                    return;
                }

                try {
                    const covenantRef = doc(getCovenantsCollectionRef(), covenantId);
                    const initialScores = CORE_VALUES.reduce((acc, val) => ({ ...acc, [val.id]: 50 }), {});

                    const batch = writeBatch(db);
                    
                    // 1. Add member to the members array
                    batch.update(covenantRef, { 
                        members: arrayUnion(newMemberId),
                        lastUpdate: Date.now(),
                    });
                    
                    // 2. Initialize scores for the new member
                    batch.update(covenantRef, {
                        [`scores.${newMemberId}`]: initialScores,
                        history: arrayUnion({ 
                            timestamp: Date.now(), 
                            event: "Member Added", 
                            details: `${formatUserId(newMemberId)} joined the covenant.` 
                        })
                    });

                    await batch.commit();

                } catch (e) {
                    console.error("Error adding member:", e);
                }
            }, [db, getCovenantsCollectionRef, covenants]);

            const leaveCovenant = useCallback(async (covenantId) => {
                if (!db || !covenantId || !userId) return;

                try {
                    const covenantRef = doc(getCovenantsCollectionRef(), covenantId);
                    
                    const batch = writeBatch(db);

                    // 1. Remove member from the members array
                    batch.update(covenantRef, { 
                        members: arrayRemove(userId),
                        lastUpdate: Date.now(),
                    });
                    
                    batch.update(covenantRef, {
                        history: arrayUnion({ 
                            timestamp: Date.now(), 
                            event: "Member Left", 
                            details: `${formatUserId(userId)} left the covenant.` 
                        })
                    });
                    
                    await batch.commit();

                    // Deselect the covenant if the user leaves the current one
                    if (currentCovenantId === covenantId) {
                        setCurrentCovenantId(null);
                    }
                } catch (e) {
                    console.error("Error leaving covenant:", e);
                }
            }, [db, userId, currentCovenantId, getCovenantsCollectionRef]);

            return {
                covenants,
                currentCovenant,
                currentCovenantId,
                setCurrentCovenantId,
                isLoading,
                createCovenant,
                updateMemberScore,
                addMember,
                leaveCovenant,
            };
        };

        // --- Component: Header ---
        const Header = ({ userId, auth }) => {
            const handleSignOut = async () => {
                if (auth) {
                    await signOut(auth);
                }
            };

            // SVG for the TRU Logo
            const TruLogoSvg = () => (
                <svg viewBox="0 0 300 300" className="w-8 h-8 md:w-10 md:h-10 text-lime-400" xmlns="http://www.w3.org/2000/svg">
                    {/* Simplified geometric version of the TRU logo */}
                    <path fill="#121212" d="M150 0 L300 150 L150 300 L0 150 Z" />
                    <path fill="#ffffff" d="M150 20 L280 150 L150 280 L20 150 Z" />
                    {/* Stylized 'T' 'R' 'U' paths in black and lime */}
                    <path fill="#121212" d="M80 110 h140 v20 h-140 z" />
                    <path fill="#121212" d="M110 50 v100 h-20 v-100 z" />
                    <path fill="#121212" d="M220 50 v100 h-20 v-50 h-30 v50 h-20 v-100 h20 v80 h30 v-80 z" />
                    {/* Lime accent for the path/mountain peak (symbolic) */}
                    <path fill="currentColor" d="M150 150 L170 180 L130 180 Z" />
                    <path fill="currentColor" d="M150 220 L160 230 L140 230 Z" />
                </svg>
            );


            return (
                <header className="bg-tru-black text-white p-4 shadow-xl flex justify-between items-center fixed top-0 left-0 w-full z-10 border-b-4 border-lime-500">
                    <div className="flex items-center space-x-2">
                        <TruLogoSvg />
                        <h1 className="text-xl md:text-2xl font-black tracking-tight text-lime-400">
                            TROTH COVENANT CONSOLE
                        </h1>
                    </div>
                    <div className="flex items-center space-x-3">
                        {userId && (
                            <span className="text-xs sm:text-sm bg-gray-700 px-3 py-1 rounded-full border border-lime-600 text-gray-200 font-mono" title={userId}>
                                Agent: {formatUserId(userId)}
                            </span>
                        )}
                        <button
                            onClick={handleSignOut}
                            className="text-sm px-3 py-1 bg-red-600 hover:bg-red-700 transition duration-150 rounded-full font-semibold shadow-md"
                        >
                            Logout
                        </button>
                    </div>
                </header>
            );
        };

        // --- Component: ScoreCard ---
        const ScoreCard = ({ userId, score, valueId, label, updateScore, disabled }) => {
            const [inputValue, setInputValue] = useState(score.toString());

            useEffect(() => {
                setInputValue(score.toString());
            }, [score]);

            const handleChange = (e) => {
                setInputValue(e.target.value);
            };

            const handleBlur = () => {
                let newScore = parseInt(inputValue, 10);
                if (isNaN(newScore)) {
                    newScore = 50; // Default if empty/invalid
                }
                newScore = Math.max(0, Math.min(MAX_CORE_SCORE, newScore));
                setInputValue(newScore.toString());
                updateScore(newScore);
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.target.blur(); // Trigger blur to save the score
                }
            };

            const color = valueId === 'integrity' ? 'bg-sky-700' 
                : valueId === 'functionality' ? 'bg-amber-600' 
                : 'bg-emerald-600';
            
            const percentage = Math.max(0, Math.min(100, score));

            return (
                <div className="bg-gray-800 rounded-xl shadow-lg border border-gray-700 overflow-hidden transform hover:scale-[1.01] transition duration-300">
                    <div className={`p-3 text-white ${color}`}>
                        <h3 className="text-sm font-bold uppercase tracking-wider">{label}</h3>
                    </div>
                    <div className="p-4">
                        <div className="flex justify-between items-center mb-2">
                            <p className="text-4xl font-extrabold text-lime-400 drop-shadow-lg">{score}</p>
                            <div className="text-sm text-gray-400">/{MAX_CORE_SCORE}</div>
                        </div>
                        
                        <div className="w-full bg-gray-700 rounded-full h-2.5 mb-4">
                            <div 
                                className={`h-2.5 rounded-full ${color.replace('bg-', 'bg-')}`} 
                                style={{ width: `${percentage}%` }}
                            ></div>
                        </div>
                        
                        <div className="mt-4 flex items-center 
